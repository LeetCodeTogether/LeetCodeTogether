{
    "submissions_dump": [
        {
            "id": 313228514,
            "lang": "java",
            "time": "1 week, 5 days",
            "timestamp": 1584427042,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/313228514/",
            "is_pending": "Not Pending",
            "title": "Two Sum",
            "memory": "41.9 MB",
            "code": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> visited = new HashMap<>();\n        int c;\n        for (int i = 0; i < nums.length; i++) {\n            if (visited.containsKey(nums[i])) {\n                c = visited.get(nums[i]);\n                return new int[] {c, i};\n            } else {\n                c = target - nums[i];\n                visited.put(c, i);\n            }\n        }\n        return null;\n    }\n}",
            "compare_result": "11111111111111111111111111111"
        },
        {
            "id": 312877674,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326773,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/312877674/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "37.7 MB",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = (y > 0) ? matrix[0].length : 0;\n        int a = 0, b = 0, i = a, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "1111111111111111111111"
        },
        {
            "id": 312877414,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326713,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/312877414/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = (y > 0) ? matrix[0].length : 0;\n        int a = 0, b = 0, i = a, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: {\n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                }\n                case 1: {\n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                }\n                case 2: {\n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                }\n                case 3: {\n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                }\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "0000000000000000000000"
        },
        {
            "id": 312877049,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326629,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/312877049/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "37.3 MB",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = (y > 0) ? matrix[0].length : 0;\n        int a = 0, b = 0, i = a, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "1111111111111111111111"
        },
        {
            "id": 312876983,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326611,
            "status_display": "Compile Error",
            "runtime": "N/A",
            "url": "/submissions/detail/312876983/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = (y > 0) ? matrix[0].length : 0;\n        int a = 0, b = 0, i, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": null
        },
        {
            "id": 312876773,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326560,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/312876773/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "37.7 MB",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = (y > 0) ? matrix[0].length : 0;\n        int a = 0, b = 0, i = 1, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "1111111111111111111111"
        },
        {
            "id": 312876488,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326488,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/312876488/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int y = matrix.length, x = matrix[0].length;\n        int a = 0, b = 0, i = 1, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "1100000000000000000000"
        },
        {
            "id": 312876198,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584326420,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/312876198/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int x = matrix[0].length, y = matrix.length;\n        int a = 0, b = 0, i = 1, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        int select = 0;\n        while (a < x && b < y) {\n            select = select % 4;\n            switch (select) {\n                case 0: \n                    // going left to right\n                    for (i = a; i < x; i++) {\n                        ans.add(matrix[j+1][i]);\n                    }\n                    b++;\n                    break;\n                case 1: \n                    // going top to bottom \n                    for (j = b; j < y; j++) {\n                        ans.add(matrix[j][i-1]);\n                    }\n                    x--;\n                    break;\n                case 2: \n                    // going right to left\n                    for (i = x-1; i >= a; i--) {\n                        ans.add(matrix[j-1][i]);\n                    }\n                    y--;\n                    break;\n                case 3: \n                    // going bottom to up\n                    for (j = y-1; j >= b; j--) {\n                        ans.add(matrix[j][i+1]);\n                    }\n                    a++;\n                    break;\n            }\n            select++; \n        }\n        return ans;\n    }\n}",
            "compare_result": "1100000000000000000000"
        },
        {
            "id": 312868845,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584324759,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/312868845/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int x = matrix[0].length, y = matrix.length;\n        int a = 0, b = 0, i, j = -1;\n        List<Integer> ans = new ArrayList<>();\n        while (a < x && b < y) {\n            // going left to right\n            for (i = a; i < x; i++) {\n                ans.add(matrix[j+1][i]);\n            }\n            b++;\n            // going top to bottom \n            for (j = b; j < y; j++) {\n                ans.add(matrix[j][i-1]);\n            }\n            x--;\n            // going right to left\n            for (i = x-1; i >= a; i--) {\n                ans.add(matrix[j-1][i]);\n            }\n            y--;\n            // going bottom to up\n            for (j = y-1; j >= b; j--) {\n                ans.add(matrix[j][i+1]);\n            }\n            a++;\n        }\n        return ans;\n    }\n}",
            "compare_result": "1000000000000000000000"
        },
        {
            "id": 312867838,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584324516,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/312867838/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int x = matrix[0].length, y = matrix.length;\n        int a = 0, b = 0, i, j = 1;\n        List<Integer> ans = new ArrayList<>();\n        while (a < x && b < y) {\n            // going left to right\n            for (i = a; i < x; i++) {\n                ans.add(matrix[j-1][i]);\n            }\n            b++;\n            // going top to bottom \n            for (j = b; j < y; j++) {\n                ans.add(matrix[j][i-1]);\n            }\n            x--;\n            j--;\n            // going right to left\n            for (i = x-1; i >= a; i--) {\n                ans.add(matrix[j-1][i]);\n            }\n            y--;\n            i++;\n            // going bottom to up\n            for (j = y-1; j >= b; j--) {\n                ans.add(matrix[j][i+1]);\n            }\n            a++;\n            j++;\n        }\n        return ans;\n    }\n}",
            "compare_result": "0000000000000000000000"
        },
        {
            "id": 312866041,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584324109,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/312866041/",
            "is_pending": "Not Pending",
            "title": "Spiral Matrix",
            "memory": "N/A",
            "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int x = matrix[0].length, y = matrix.length;\n        int a = 0, b = 0, i, j = b;\n        List<Integer> ans = new ArrayList<>();\n        while (a < x && b < y) {\n            // going left to right\n            for (i = a; i < x; i++) {\n                ans.add(matrix[j][i]);\n            }\n            b++;\n            i--;\n            // going top to bottom \n            for (j = b; j < y; j++) {\n                ans.add(matrix[j][i]);\n            }\n            x--;\n            j--;\n            // going right to left\n            for (i = x-1; i >= a; i--) {\n                ans.add(matrix[j][i]);\n            }\n            y--;\n            i++;\n            // going bottom to up\n            for (j = y-1; j >= b; j--) {\n                ans.add(matrix[j][i]);\n            }\n            a++;\n            j++;\n        }\n        return ans;\n    }\n}",
            "compare_result": "1000000000000000000000"
        },
        {
            "id": 312851322,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584320791,
            "status_display": "Accepted",
            "runtime": "1 ms",
            "url": "/submissions/detail/312851322/",
            "is_pending": "Not Pending",
            "title": "Product of Array Except Self",
            "memory": "47.7 MB",
            "code": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int L = nums.length;\n        int[] ans = new int[L];\n        ans[0] = 1;\n        for (int i = 1; i < L; i++) {\n            ans[i] = ans[i-1] * nums[i-1];\n        }\n        int product = nums[L-1];\n        for (int i = L - 2; i >= 0; i--) {\n            ans[i] *= product;\n            product *= nums[i];\n        }\n        return ans;\n    }\n}",
            "compare_result": "111111111111111111"
        },
        {
            "id": 312614218,
            "lang": "java",
            "time": "2 weeks",
            "timestamp": 1584258856,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/312614218/",
            "is_pending": "Not Pending",
            "title": "Reverse Linked List",
            "memory": "38.4 MB",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode n = head, m;\n        head = head.next;\n        n.next = null;\n        while (head != null) {\n            m = head;\n            head = head.next;\n            m.next = n;\n            n = m;\n        }\n        return n;\n    }\n}",
            "compare_result": "111111111111111111111111111"
        },
        {
            "id": 312122076,
            "lang": "java",
            "time": "2 weeks, 2 days",
            "timestamp": 1584122406,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/312122076/",
            "is_pending": "Not Pending",
            "title": "Missing Number",
            "memory": "43.2 MB",
            "code": "class Solution {\n    public int missingNumber(int[] nums) {\n        int L = nums.length, sumAll = 0;\n        for (int i = 1; i <= L; i++) {\n            sumAll += i;\n        }\n        for (int i = 0; i < L; i++) {\n            sumAll -= nums[i];\n        }\n        return sumAll;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
        },
        {
            "id": 311250829,
            "lang": "java",
            "time": "2 weeks, 5 days",
            "timestamp": 1583862296,
            "status_display": "Accepted",
            "runtime": "0 ms",
            "url": "/submissions/detail/311250829/",
            "is_pending": "Not Pending",
            "title": "First Missing Positive",
            "memory": "37.5 MB",
            "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int outOfRangeNumber = nums.length + 1; // impossible number\n        // replace all negative numbers with a positive number that is out of range\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] <= 0) nums[i] = outOfRangeNumber;\n        }\n        // at this point there is no negative numbers in the array\n        // for each number X (within range) - change a value at the index X - 1 to negative (only one time, we don't care about the duplicates)\n        // negative value at index I - means number I + 1 exists in the original array \n        for (int i = 0; i < nums.length; i++) {\n            int absCurrNum = Math.abs(nums[i]); // absolute value of the current number\n            if (absCurrNum <= nums.length && // if the number is within the range\n                nums[absCurrNum - 1] > 0) { // and the number at that index was not met yet\n                    nums[absCurrNum - 1] *= -1; // change to negative value to denote number absCurrNum exists in the original array \n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] >= 0) { // the first positive number means number I + 1 doesn't exist in the original array \n                return i + 1;\n            }\n        }\n        return nums.length + 1; // if there are no positive values - the next first missing will be nums.length + 1\n    }\n}",
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
        },
        {
            "id": 311250738,
            "lang": "java",
            "time": "2 weeks, 5 days",
            "timestamp": 1583862272,
            "status_display": "Compile Error",
            "runtime": "N/A",
            "url": "/submissions/detail/311250738/",
            "is_pending": "Not Pending",
            "title": "First Missing Positive",
            "memory": "N/A",
            "code": "public int firstMissingPositive(int[] nums) {\n        int outOfRangeNumber = nums.length + 1; // impossible number\n        // replace all negative numbers with a positive number that is out of range\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] <= 0) nums[i] = outOfRangeNumber;\n        }\n        // at this point there is no negative numbers in the array\n        // for each number X (within range) - change a value at the index X - 1 to negative (only one time, we don't care about the duplicates)\n        // negative value at index I - means number I + 1 exists in the original array \n        for (int i = 0; i < nums.length; i++) {\n            int absCurrNum = Math.abs(nums[i]); // absolute value of the current number\n            if (absCurrNum <= nums.length && // if the number is within the range\n                nums[absCurrNum - 1] > 0) { // and the number at that index was not met yet\n                    nums[absCurrNum - 1] *= -1; // change to negative value to denote number absCurrNum exists in the original array \n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] >= 0) { // the first positive number means number I + 1 doesn't exist in the original array \n                return i + 1;\n            }\n        }\n        return nums.length + 1; // if there are no positive values - the next first missing will be nums.length + 1\n    }",
            "compare_result": null
        },
        {
            "id": 311250389,
            "lang": "java",
            "time": "2 weeks, 5 days",
            "timestamp": 1583862178,
            "status_display": "Wrong Answer",
            "runtime": "N/A",
            "url": "/submissions/detail/311250389/",
            "is_pending": "Not Pending",
            "title": "First Missing Positive",
            "memory": "N/A",
            "code": "class Solution {\n    public int firstMissingPositive(int[] nums) {\n        if(nums == null){\n            return 1;\n        }\n        int n = nums.length;\n        for(int i = 0; i < n; i ++){\n            if(nums[i] <= 0){\n                nums[i] = n + 1;  // if the number <=0, the number is not a positive integer, just set it a big number so it won't affect the index count\n            }\n        }\n        for(int i = 0; i < n; i ++){\n            int index = Math.abs(nums[i]) - 1;\n            if(index < n && nums[i] > 0){\n               nums[index] *= -1;  // set number at index to negative.\n            }  \n        }\n        for(int i = 0; i < n; i ++){\n            if(nums[i] > 0){\n                return i + 1;  // if a number is positive, it means the index's number is not in array\n            }\n        }\n        return n + 1; // if all numbers are positive, means the numbers in array are [1..n]\n    }\n}",
            "compare_result": "101111111111100111111111011001100000001110011111010111111111101101111101110111011101111101111101111101111010111000010100001001000010000000001110101000011101111000011"
        },
        {
            "id": 310522497,
            "lang": "java",
            "time": "3 weeks",
            "timestamp": 1583662251,
            "status_display": "Accepted",
            "runtime": "250 ms",
            "url": "/submissions/detail/310522497/",
            "is_pending": "Not Pending",
            "title": "Merge k Sorted Lists",
            "memory": "41.3 MB",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode merged = new ListNode(0);\n        ListNode store = merged;\n        Integer min;\n        int minIndex = -1;\n        boolean nodesRemaining = true;\n        while (nodesRemaining) {\n            min = null;\n            for (int i = 0; i < lists.length; i++) {\n                if (lists[i] != null && \n                    (min == null || lists[i].val < min)) {\n                    min = lists[i].val;\n                    minIndex = i;\n                }\n            }\n            if (min != null) {\n                store.next = new ListNode(min);\n                store = store.next;\n                lists[minIndex] = lists[minIndex].next;\n            } else {\n                nodesRemaining = false;\n            }\n        }\n        return merged.next;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
        },
        {
            "id": 310522397,
            "lang": "java",
            "time": "3 weeks",
            "timestamp": 1583662216,
            "status_display": "Accepted",
            "runtime": "286 ms",
            "url": "/submissions/detail/310522397/",
            "is_pending": "Not Pending",
            "title": "Merge k Sorted Lists",
            "memory": "40.9 MB",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        // if (lists.length == 0) return null;\n        ListNode merged = new ListNode(0);\n        ListNode store = merged;\n        Integer min;\n        int minIndex = -1;\n        boolean nodesRemaining = true;\n        while (true) {\n            nodesRemaining = false;\n            min = Integer.MAX_VALUE;\n            for (int i = 0; i < lists.length; i++) {\n                if (lists[i] != null && lists[i].val < min) {\n                    min = lists[i].val;\n                    minIndex = i;\n                }\n                if (min < Integer.MAX_VALUE) {\n                    nodesRemaining = true;\n                }\n            }\n            if (!nodesRemaining) {\n                break;\n            }\n            store.next = new ListNode(min);\n            store = store.next;\n            lists[minIndex] = lists[minIndex].next;\n        }\n        return merged.next;\n    }\n}",
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"
        },
        {
            "id": 310521129,
            "lang": "java",
            "time": "3 weeks",
            "timestamp": 1583661785,
            "status_display": "Runtime Error",
            "runtime": "N/A",
            "url": "/submissions/detail/310521129/",
            "is_pending": "Not Pending",
            "title": "Merge k Sorted Lists",
            "memory": "N/A",
            "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        // if (lists.length == 0) return null;\n        ListNode merged = new ListNode(0);\n        ListNode store = merged;\n        Integer min;\n        int minIndex = -1;\n        boolean nodesRemaining = true;\n        while (nodesRemaining) {\n            min = Integer.MAX_VALUE;\n            for (int i = 0; i < lists.length; i++) {\n                if (lists[i] != null && lists[i].val < min) {\n                    min = lists[i].val;\n                    minIndex = i;\n                }\n            }\n            if (min != null) {\n                store.next = new ListNode(min);\n                store = store.next;\n                lists[minIndex] = lists[minIndex].next;\n            } else {\n                nodesRemaining = false;\n            }\n        }\n        return merged.next;\n    }\n}",
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22310521129%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222020-03-08T10%3A03%3A05.909060%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%222635875%22%7D%7D"
}